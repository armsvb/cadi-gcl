#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_dma.h"
#include "stm32f10x_conf.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "stm32f10x_flash.h"
#include "eeprom.h"
#include "ff9a/src/diskio.h"
#include "ff9a/src/ff.h"

// define eeprom cells for keeping settings

#define PLUG_DISABLE	GPIOC->BSRR
#define PLUG_ENABLE		GPIOC->BRR

#define	PLUG_INVERT			0		// enable reverse plugStateSet
#define LIGHT_RANGE_ADDR	0x7CFF	// the border for the light sensor trigger
#define EE_PLUG_SETTINGS	0x7D00
#define EE_TIMER1_ON		0x8000
// #define EE_CTIMER			0x7E00
#define EE_CTIMER_DURATION	0x7E00
#define EE_CTIMER_INTERVAL	0x7E02
#define EE_TIMER_SIZE		10
#define EE_CTIMER_SIZE		5
#define PLUG_AMOUNT			3		// this links to number of pins on PORTC, so not more then 16
#define LS2CT_ADDR			0x7C00	// 64 tajmera tipa LS+2CT (16bit na tajmer)
#define	ADDLIGHT_ADDR		0x7C40	// 128 tajmerov dosveta (8 bit na tajmer)
#define	T2CT_ADDR			0x7C80	// 63 tajmera tipa 1obychnyj+2ckilicheskih
#define PH4_ADDR			0x0600
#define PH7_ADDR			0x0601
#define PH_INTERVAL			0x0602		// pH measurement interval in milliseconds
#define PH_BUFF_SIZE		0x0603		// pH buffer size
#define SD_LOG_INTERVAL		0x0620		// sd logging interval, seconds

#define YEAR12SECS	1325462400	// vse raschety vedjom ot 01.01.2012
#define BUTTON_OK	2
#define BUTTON_CNL	3
#define BUTTON_BCK	1
#define BUTTON_FWD	4
#define DAY			1
#define NIGHT		0
#define port    	GPIOB
#define init_port 	RCC_APB2Periph_GPIOB
#define pin_e 		GPIO_Pin_7
#define pin_rw		GPIO_Pin_8
#define pin_rs		GPIO_Pin_9
#define lcd_port	GPIOB
#define BSRRL		BSRR
#define BSRRH		BRR


#define LOG_SHIFT	1


#define JDR_BUTTONS	ADC1->JDR4
#define JDR_PH		ADC1->JDR2

#define lcd_shift	11
#define use_gpio	GPIO_Pin_14
#define pin_d7		use_gpio
#define pin_d6		use_gpio>>1
#define pin_d5		use_gpio>>2
#define pin_d4		use_gpio>>3

#define Function_set 				0b00100000//4-bit,2 - line mode, 5*8 dots
#define Display_on_off_control		0b00001100/// display on,cursor off,blink off
#define Display_clear				0b00000001
#define Entry_mode_set				0b00000100//

#define rs_1	port->ODR |=  pin_rs
#define rs_0	port->ODR &=~ pin_rs
#define e_1 	port->ODR |=  pin_e
#define e_0		port->ODR &=~ pin_e
#define rw_1	port->ODR |=  pin_rw
#define rw_0	port->ODR &=~ pin_rw
u32 del;
/*const unsigned char russian[]={ 0x41, 0xA0, 0x42, 0xA1, 0xE0, 0x45,
0xA3, 0xA4, 0xA5,0xA6, 0x4B, 0xA7, 0x4D, 0x48, 0x4F, 0xA8, 0x50,0x43,
0x54, 0xA9, 0xAA, 0x58, 0xE1, 0xAB, 0xAC, 0xE2, 0xAD,0xAE, 0x62,
0xAF, 0xB0, 0xB1, 0x61, 0xB2, 0xB3, 0xB4, 0xE3, 0x65, 0xB6, 0xB7,
0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0x6F, 0xBE, 0x70, 0x63,0xBF,
0x79, 0xE4, 0x78, 0xE5, 0xC0, 0xC1, 0xE6, 0xC2,0xC3, 0xC4, 0xC5,
0xC6, 0xC7 }; */

typedef struct
{
  unsigned char  hour;     //Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¹
  unsigned char  min;	   //Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹
  unsigned char  sec;	   //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã¢â‚¬Â¹
} RTC_Time;

typedef struct
{
  uint16_t  hour;     //Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¹
  uint16_t  min;	   //Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹
  uint16_t  sec;	   //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã¢â‚¬Â¹
  uint16_t  day;	   //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã¢â‚¬Â¹
  uint16_t  month;	   //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã¢â‚¬Â¹
  uint16_t  year;	   //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã¢â‚¬Â¹
  uint16_t  doy;	   //day of year

} RTC_DateTime;

static uint8_t		LCDLine1[16], LCDLine2[16];
uint8_t lcd_pointerx=0, lcd_pointery=0;
uint16_t logInterval=0;
RTC_Time toAdjust;
ErrorStatus  HSEStartUpStatus;
FLASH_Status FlashStatus;
int no_sd;
FATFS   fs;                   //Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°, Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Âº
uint16_t VarValue = 0;
uint16_t ph_seven=0;
uint32_t ph0=0;
uint16_t ph4=0;
int cdel=0;
uint16_t phBuffer[10];
char curphstr[5];
uint16_t phAdcValue;
uint32_t lastWriteTime=0;
//uint16_t ph_seven, ph4;
uint8_t lightSensor;
uint16_t lightRange;
uint32_t timerStateFlags, cTimerStateFlags;
uint32_t plugStateFlags;
uint8_t plugSettings[PLUG_AMOUNT] = {0, 1, 2};	// PLUG_AMOUNT - number of plugs HARDCODE
// elementy massiva - nomera tajmerov, sootvetstvujushih Plug'am.
// 0 element - pervyj plug, 1 element - plug no 2, etc
uint16_t button_ranges[8];	// 0,2,4,6 - lower, 1,3,5,7 - higher values for buttons

void phMonSettings(void);
void setTimer(uint8_t timerId);
void copy_arr(uint8_t *source, uint8_t *destination, uint8_t amount, uint8_t pos);
void Lcd_write_arr(uc8 *STRING, uint8_t chars);
void Lcd_write_digit(uint8_t numb);
void Delay_us(uint32_t delay);
void buttonCalibration(void);
void Init_pin_out(void);
void Init_pin_in(void);
void Init_lcd(void);
void Lcd_write_data(uint8_t byte);
void Lcd_write_cmd(uint8_t byte);
void Lcd_clear(void);
void Return_home(void);
void Lcd_goto(uc8 x, uc8 y);
void Lcd_write_str(char *STRING);
char* adc2str(uint_fast16_t d, char* out);
void int32str(uint32_t d, char *out);
void AdcInit(void);
uint32_t RTC_GetCounter(void);
void RTC_SetCounter(uint32_t value);
unsigned char RtcInit(void);
uint8_t readButtons(void);
void focusMenuItem(int itemId);
int menuSelector(void);
uint32_t timeAdjust(uint32_t cnt, uint8_t includeDays);
void programRunner(uint8_t programId);
RTC_DateTime unix2DateTime(uint32_t unixtime);
uint32_t DateTime2unix(RTC_DateTime datetime);
void EE_WriteWord(uint16_t Address, uint32_t Data);
uint32_t EE_ReadWord(uint16_t Address);
//void Lcd_print(char *STRING);
void setCTimer(uint8_t timerId);
uint32_t CTimerAdjust(uint32_t time);
void plugStateSet(uint8_t plug, uint8_t state);
void getPh();
FRESULT string2log(char* str, int bytes);
FRESULT sdLog2(void);
uint8_t adjust8bit(uint8_t val);
void loggerSettings(void);
int yesNoSelector(char str, int curval);
void loadSettings(void);
void set4lowBits(uint8_t dta);
void set4highBits(uint8_t dta);
void flush_lcd_buffer(void);

static void prvSetupHardware( void );
static void prvLedBlink( void *pvParameters );
static void prvLedBlink2( void *pvParameters );
static void displayClock( void *pvParameters );
static void timerStateTrigger(void *pvParameters);
static void plugStateTrigger(void  *pvParameters);
static void sdLog(void  *pvParameters);
static void phMonitor(void  *pvParameters);
static void vTaskLCDdraw(void *pvParameters);

typedef struct
{
    uint32_t quot;
    uint8_t rem;
} divmod10_t;
inline static divmod10_t divmodu10(uint32_t n)
{
    divmod10_t res;
// Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â° 0.8
    res.quot = n >> 1;
    res.quot += res.quot >> 1;
    res.quot += res.quot >> 4;
    res.quot += res.quot >> 8;
    res.quot += res.quot >> 16;
    uint32_t qq = res.quot;
// Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â° 8
    res.quot >>= 3;
// Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Âº
    res.rem = n - ((res.quot << 1) + (qq & ~7ul));
// Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Âº Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Âµ
    if(res.rem > 9)
    {
        res.rem -= 10;
        res.quot++;
    }
    return res;
}


/* Virtual address defined by the user: 0xFFFF value is prohibited */
uint16_t VirtAddVarTab[2] = {
			EE_TIMER1_ON,
			EE_CTIMER_DURATION
};


#define MENURECS	23

// menu items
const char menuItemArray[MENURECS][18]=
{
		{"SYSTEM STATUS"},		// 0
		{"TIMERS"},				// 1
		{"Timer 1"},			// 2
		{"Timer 2"},			// 3
		{"Timer 3"},			// 4
		{"SET CLOCK"},			// 5
		{"CYCLIC TIMERS"},			// 6
		{"Cyclic Timer 1"},			// 7
		{"Cyclic Timer 2"},			// 8
		{"Cyclic Timer 3"},			// 9
		{"PLUG SETTINGS"},			// 10
		{"Plug 1"},			// 11
		{"Plug 2"},			// 12
		{"Plug 3"},			// 13
		{"pH-monitor"},		// 14
		{"Calibration"},	// 15
		{"Monitor settings"},	// 16
		{"DAYLIGHT SENSOR"},// 17
		{"COMBI TIMERS"},	// 18
		{"LS+2CT"},	// 19
		{"T+2CT"},	// 20
		{"Add Light"},	// 21
		{"Logger settings"}	// 22

};

// 0 - nr zapisi, 1 - link na tekst, 2 - <, 3 - >, 4 - OK, 5 - CNCL, 6 - tip zapisi (0 - folder, 1 - program)
const int fatArray[MENURECS][7]=
{
		{0,	0,	18,	1,	1,	0,	1},
		{1,	1,	0,	5,	2,	1,	0},
		{2,	2,	4,	3,	2,	1,	1},
		{3,	3,	2,	4,	3,	1,	1},
		{4,	4,	3,	2,	4,	1,	1},
		{5,	5,	1,	6,	5,	5,	1},
		{6,	6,	5,	10,	7,	6,	0},
		{7,	7,	9,	8,	6,	6,	1},
		{8,	8,	7,	9,	7,	6,	1},
		{9,	9,	8,	7,	8,	6,	1},
		{10,10,	6,	14,	11,	10,	0},
		{11,11,	13,	12,	9,	10,	1},
		{12,12,	11,	13,	10,	10,	1},
		{13,13,	12,	11,	11,	10,	1},
		{14,14,	10,	17,	15,	14,	0},
		{15,15,	16,	16,	15,	14,	1},
		{16,16,	15,	15,	13,	14,	1},
		{17,17,	14,	18,	14,	17,	1},
		{18,18,	17,	22,	19,	18,	0},
		{19,19,	21,	20,	15,	19,	1},
		{20,20,	19,	21,	16,	20,	1},
		{21,21,	20,	19,	17,	21,	1},
		{22,22,	18,	0,	17,	22,	1}

};

char* adc2str(uint_fast16_t d, char* out)
{
	char out2[17];
	int i, k, c;
    out2[16] = '\0';
    out2[15] = '0' + ( d       )    % 10;
    out2[14] = '0' + ( d /= 10 )    % 10;
    out2[13] = '0' + ( d /= 10 )    % 10;
    out2[12] = '0' + ( d /= 10 )    % 10;
    out2[11] = '0' + ( d /= 10 )    % 10;
    out2[10] = '0' + ( d /= 10 )    % 10;
    vTaskDelay(25);
    out2[9] = '0' + ( d /= 10 )    % 10;
    out2[8] = '0' + ( d /= 10 )    % 10;
    out2[7] = '0' + ( d /= 10 )    % 10;
    out2[6] = '0' + ( d /= 10 )    % 10;
    out2[5] = '0' + ( d /= 10 )    % 10;
    out2[4] = '0' + ( d /= 10 )    % 10;
    out2[3] = '0' + ( d /= 10 )    % 10;
    out2[2] = '0' + ( d /= 10 )    % 10;
    out2[1] = '0' + ( d /= 10 )    % 10;
    out2[0] = '0' + ( d /  10 )    % 10;
    k=0;
    c=out2[k];
    c=48;

	vTaskDelay(25);
	while (c==48){
    	k++;
    	c=out2[k];
	}
	vTaskDelay(25);
	for (i=k; i<17; i++){
		out[i-k]=out2[i];
	}

    return out;
}

FRESULT sdLog2(void){
	char str[20];
	char tmpstr[15];
	int i;
	uint32_t tmp;
	tmp = RTC_GetCounter();
	FRESULT resp=0;

		int32str(tmp, &tmpstr);
		for (i=0; i<10; i++){
			str[i]=tmpstr[i];
		}
		str[10]=44;
		int32str(JDR_BUTTONS, &tmpstr);
		for (i=0;i<4;i++){
			str[i+11]=tmpstr[i+6];
		}
		str[16]=44;
		str[17]=13;
		resp = string2log(&str, 17);
	return resp;
}

void Delay_us(uint32_t delay){
	uint32_t del=delay*250; while (del--){}
}


void buttonCalibration(void){	// buttons calibration function
	uint16_t button_val[4], diff;
	Lcd_clear();
	Lcd_goto(0,0);
	Lcd_write_arr("1", 1);
	Delay_us(10000);
	Delay_us(100);
	button_val[0] = JDR_BUTTONS;
	Lcd_goto(0,0);
	Lcd_write_arr("2", 1);
	Delay_us(10000);
	Delay_us(100);
	button_val[1] = JDR_BUTTONS;
	diff = ((button_val[1]-button_val[0])/2)-5;
	button_ranges[0] = button_val[0]-diff;
	button_ranges[1] = button_val[0]+diff;
	button_ranges[2] = button_val[1]-diff;
	Lcd_goto(0,0);
	Lcd_write_arr("3", 1);
	Delay_us(10000);
	Delay_us(100);
	button_val[2] = JDR_BUTTONS;
	diff = ((button_val[2]-button_val[1])/2)-5;
	button_ranges[3] = button_val[1]+diff;
	button_ranges[4] = button_val[2]-diff;
	Lcd_goto(0,0);
	Lcd_write_arr("4", 1);
	Delay_us(10000);
	Delay_us(100);
	button_val[3] = JDR_BUTTONS;
	diff = ((button_val[3]-button_val[2])/2)-5;
	button_ranges[5] = button_val[2]+diff;
	button_ranges[6] = button_val[3]-diff;
	button_ranges[7] = button_val[3]+diff;
	Lcd_goto(0,0);
	Lcd_write_str("Calib. Complete");
}

static void sdLog(void *pvParameters){
	char str[20], tmpstr[15];
	int i;
	uint32_t tmp;
	vTaskDelay(150);
	while(1){
	tmp = RTC_GetCounter();
		vTaskDelay(100);
		if (tmp>lastWriteTime+logInterval) {
			int32str(tmp, &tmpstr);
			vTaskDelay(100);
			for (i=0; i<10; i++){
				str[i]=tmpstr[i];	// current time
			}
			vTaskDelay(100);
			str[10]=44;	// ascii comma

			vTaskDelay(100);
			vTaskSuspendAll();
			for (i=0;i<4;i++){
				str[i+11]=curphstr[i];	// current pH value
			}
			xTaskResumeAll();
			vTaskDelay(100);
			str[15]=44;
			uint16_t flg=0;
	    	for (i=0; i<3; i++) {
	    		flg=plugStateFlags&(1<<i);	// plug state flags
	    		flg>>=i;
	    		str[i+16]=flg+48;
	    	}
//			str[20]=13;		// CR
			str[19]=10;		// LF
			string2log(&str, 20);
			vTaskDelay(100);
			lastWriteTime=RTC_GetCounter();
		}
		vTaskDelay(100);
	}
}



FRESULT string2log(char* str, int bytes){
	FRESULT res;               //Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Â°Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒâ€˜Ã¢â‚¬Å¾Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â·Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã…â€™Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°
	if (no_sd==0) {
		  static FIL logfile;
		  UINT len;
		  char FileName[]="0:CADIZLOG";
	//	  logfile = malloc(sizeof (FIL));
	//      taskENTER_CRITICAL();
		  vTaskSuspendAll();

		  res = f_open(&logfile, FileName, FA_WRITE | FA_READ);
	//	  vTaskDelay(50);
		  if(res) {
			  res = f_open(&logfile, FileName, FA_WRITE | FA_CREATE_ALWAYS);
	//		  vTaskDelay(50);
			  if(res) return res;
		  };
		  res = f_lseek(&logfile, f_size(&logfile));
		  if(res) return res;

		  res = f_write(&logfile, str, bytes, &len);
		  if(res) return res;
		  res = f_sync(&logfile);
		  if(res) return res;

		  res = f_close(&logfile);
	//      taskEXIT_CRITICAL();
		  xTaskResumeAll();
	}
	else {
		res=0;	// force 0 output for no functioning SD card
	}
      return res;
}

void push2str(char* str1, char* str2, char *out){
	int len1,len2,i;
	len1=sizeof(str1);
	len2=sizeof(str2);
	for (i=0;i<len1;i++) {
		out[i]=str1[i];
	}
	for (i=len1;i<(len1+len2);i++) {
		out[i]=str2[(i-len1)];
	}

}

void calibratePh(){
	int button = 0;
	uint16_t ph;
//	char phstr[4];
	char buffer[4];
//	char *pbuffer;
	while (button!=BUTTON_OK){
		button = readButtons();
//		Lcd_clear();
		vTaskDelay(5);
		Lcd_goto(0,0);
		Lcd_write_str("Use pH7");
		Lcd_goto(0,8);
		vTaskDelay(5);
//		ph_seven32 = ph_seven;
		adc2str(ph_seven, &buffer);
		Lcd_write_str(buffer);
		Lcd_goto(1,5);
		adc2str(JDR_PH, &buffer);
		Lcd_write_str(buffer);
		vTaskDelay(10);
		Lcd_goto(1,0);
    	getPh();
    	vTaskDelay(10);
    	Lcd_write_str(curphstr);
    	vTaskDelay(100);
	}
	ph=JDR_PH;
	EE_WriteVariable(PH7_ADDR, ph);
	button = 0;

	Lcd_goto(0,0);
    	Lcd_write_str("pH7 val. saved");
	vTaskDelay(2000);
	while (button!=BUTTON_OK){
		button = readButtons();
		Lcd_clear();
		vTaskDelay(25);
		Lcd_goto(0,0);
		Lcd_write_str("Use pH4");
		Lcd_goto(0,8);
    	getPh();
		adc2str(ph4, &buffer);
		Lcd_write_str(buffer);
		Lcd_goto(1,5);
		adc2str(phAdcValue, &buffer);
		Lcd_write_str(buffer);
		vTaskDelay(25);
		Lcd_goto(1,0);
    	vTaskDelay(25);
    	Lcd_write_str(curphstr);
    	vTaskDelay(500);
	}

	ph=JDR_PH;
	EE_WriteVariable(PH4_ADDR, phAdcValue);
}

void getPh() {	// current PH, please!
	uint32_t total=0, ph;
	vTaskDelay(5);
	int i;
    for(i=0; i < 10; i++) {
    	total += phBuffer[i];
	}
    phAdcValue = total/10;
	vTaskDelay(5);
	ph = ((phAdcValue - ph0)*10)/cdel;
	curphstr[3] = ph-(ph/10)*10+48;
	vTaskDelay(5);
	ph/=10;
	curphstr[2]=46;
	curphstr[1] = ph-(ph/10)*10+48;
	vTaskDelay(5);
	ph/=10;
	curphstr[0]=ph-(ph/10)*10+48;
	curphstr[4] = 0;	// konec stroki
}


char * utoa_fast_div(uint32_t value, char *buffer)
{
    buffer += 11;
    *--buffer = 0;
    do
    {
        divmod10_t res = divmodu10(value);
        *--buffer = res.rem + '0';
        value = res.quot;
    }
    while (value != 0);


    return buffer;
}


void setPlug(uint8_t plugId){
	uint8_t button;
	uint16_t Address, timerId;
//	plugId--;	// pervomu plugu sootvetstvuet nulevaja zapis' v kode (especially for menu calls)
	Lcd_clear();
	Lcd_goto(0,0);
	Lcd_write_str("Plug ");
	Lcd_write_digit(plugId);
	Lcd_write_str(" timer");
	Address = EE_PLUG_SETTINGS+plugId;
	EE_ReadVariable(Address, &timerId);
	vTaskDelay(50);
	while (button!=BUTTON_OK) {
		button=readButtons();
		vTaskDelay(25);
		if (button==BUTTON_BCK) {
			if (timerId<1) {
				timerId=99;
			}
			else {
				timerId--;
			}
		}
		if (button==BUTTON_FWD) {
			if (timerId>98) {
				timerId=0;
			}
			else {
				timerId++;
			}
		}
		Lcd_goto(1,0);
		Lcd_write_str("numero <");
		Lcd_write_digit(timerId);
		Lcd_write_str(">");
		vTaskDelay(25);
	}
	vTaskDelay(50);
	Address = EE_PLUG_SETTINGS+plugId;
	EE_WriteVariable(Address, timerId);
	loadSettings();
	Lcd_clear();
}

void timerStateTrigger(void *pvParameters){
	uint8_t i, timerStateFlag;
	uint32_t now, timer1, timer2;
	uint16_t Address;
	while (1) {
		now=RTC_GetCounter();
		for (i=0; i<3; i++){	// 32 tajmera
			Address = EE_TIMER1_ON+EE_TIMER_SIZE*i;
			timer1 = EE_ReadWord(Address);
			timer2 = EE_ReadWord(Address+2);

			// for everyday triggering
			timer1 = timer1%86400;
			timer2 = timer2%86400;
			now = now % 86400;

			vTaskDelay(300);

			// logika obychnogo tajmera dlja timerOn<timerOff
			if (now<timer2 && now>timer1) {
				timerStateFlag=1;
			}
			else {
				timerStateFlag=0;
			}

			// obratnaja logika tajmera
			if (timer1>timer2) {
				timerStateFlag^=1;	// invertirovat' timerStateFlag
			}

			if (timerStateFlag==1) {
				timerStateFlags|=(1<<i);
			}
			else {
				timerStateFlags &= ~(1<<i); // sbrosit' flag
			}
		}
		vTaskDelay(1);
		for (i=0; i<3; i++){	// do 32 tajmerov
			Address = EE_CTIMER_DURATION+EE_CTIMER_SIZE*i;
			timer1 = EE_ReadWord(Address);
			timer2 = EE_ReadWord(Address+2);
			vTaskDelay(1);
			now=RTC_GetCounter();

			// logika ciklicheskogo tajmera
			now %= timer2;
			if (now<timer1) {
				timerStateFlag=1;
				cTimerStateFlags|=(1<<i);
			}
			else {
				timerStateFlag=0;
				cTimerStateFlags &= ~(1<<i); // sbrosit' flag
			}
		}
	}
}

void plugStateTrigger(void  *pvParameters){
	uint8_t plugStateFlag, plugTimerId;
	uint8_t i;
	while (1) {
		for (i=0; i<PLUG_AMOUNT; i++){		// PC0 to PC2
			plugTimerId = plugSettings[i];	// get the ID of timer for this plug
			if (plugTimerId>=0 && plugTimerId<=31) {
				// Timer
				plugStateFlag=timerStateFlags&(1<<plugTimerId);	// check if timer active now
				plugStateFlag>>=plugTimerId;	// ostavit' toka flag
			}
			if (plugTimerId>31) {
				// CTimer
				plugTimerId-=32;
				plugStateFlag=cTimerStateFlags&(1<<plugTimerId);	// check if timer active now
				plugStateFlag>>=plugTimerId;	// ostavit' toka flag
			}
			if (plugStateFlag==1 && ((plugStateFlags>>plugTimerId)&1)==0) {
				plugStateSet(plugTimerId, 1);	// enable plug
			}
			if (plugStateFlag==0 && ((plugStateFlags>>plugTimerId)&1)==1) {
				plugStateSet(plugTimerId, 0);	// enable plug
			}

		}
		vTaskDelay(1);
	}
}

void plugStateSet(uint8_t plug, uint8_t state){
//	if (PLUG_INVERT==1) {
//		state ^= (1<<0);
//	}
	if (state==1) {
		PLUG_DISABLE = (1<<plug);
		plugStateFlags |= (1<<plug);
	}
	else {
		PLUG_ENABLE = (1<<plug);
		plugStateFlags &= ~(1<<plug);
	}
}

void lightSensorTriger() {
//	int lightSensorLevel;
//	lightSensorLevel=ADC1->JDR3;
	if (ADC1->JDR3 > lightRange) {
		lightSensor=DAY;
	}
	else {
		lightSensor=NIGHT;
	}
}

void lightRangeSet(){
	uint16_t definedLightRange, Address;
	uint_fast16_t curLevel;
//	char bfr[4];
	uint8_t button=0;
	Lcd_clear();
	Lcd_goto(0, 1);
	Lcd_write_str("Push OK to set");
	Address=LIGHT_RANGE_ADDR;
	EE_ReadVariable(Address, &definedLightRange);
//	vTaskDelay(10);
	while (button!=BUTTON_OK){
		vTaskDelay(100);
		Lcd_goto(1, 3);
		curLevel=JDR_PH;
		vTaskDelay(10);

		// po dva razrjada mozhno printovat' chto ugodno :)
		Lcd_write_digit(curLevel);
		Lcd_goto(1,1);
		curLevel /= 100;	// sledujushie dva razrjada
		vTaskDelay(10);
		Lcd_write_digit(curLevel);
		vTaskDelay(10);
		button=readButtons();
	}
	EE_WriteVariable(Address, curLevel);
	Lcd_clear();
}

void ls2ct(uint8_t timerId) {	// Setting Light sensor plus 2 cyclic timers
	uint16_t Address, timerData;
	uint8_t button, dayTimerId, sec, min, hour;
	uint32_t dayDurationUnix, dayIntervalUnix;
//	RTC_Time ctime;
	Lcd_clear();
	Lcd_goto(0,0);
	Lcd_write_str("Light sensor and");
	Lcd_goto(1,0);
	Lcd_write_str("2 cyclic timers");
	vTaskDelay(1500);
	Lcd_clear();

	Address = LS2CT_ADDR+timerId;
	EE_ReadVariable(Address, &timerData);
	dayTimerId=timerData;
//	nightTimerId=timerData<<8;
	Lcd_goto(0,0);
	vTaskDelay(25);
	Lcd_write_str("Day timer");
	vTaskDelay(25);
	while (button!=BUTTON_OK) {
		Lcd_goto(1,0);
		Address = EE_CTIMER_DURATION+dayTimerId*EE_CTIMER_SIZE;
		dayDurationUnix=EE_ReadWord(Address);
		vTaskDelay(25);
		sec = dayDurationUnix % 60;
		dayDurationUnix /= 60;
		min = dayDurationUnix % 60;
		hour = dayDurationUnix/3600;
		Lcd_write_digit(hour);
		Lcd_write_str(":");
		Lcd_write_digit(min);
		Lcd_write_str(":");
		Lcd_write_digit(sec);
		vTaskDelay(25);
		Address = EE_CTIMER_INTERVAL+dayTimerId*EE_CTIMER_SIZE;
		dayIntervalUnix=EE_ReadWord(Address);
		vTaskDelay(25);
		sec = dayIntervalUnix % 60;
		dayIntervalUnix /= 60;
		min = dayIntervalUnix % 60;
		hour = dayIntervalUnix/3600;
		Lcd_goto(1,8);
		Lcd_write_digit(hour);
		Lcd_write_str(":");
		Lcd_write_digit(min);
		Lcd_write_str(":");
		Lcd_write_digit(sec);
		vTaskDelay(25);
		button=readButtons();
		vTaskDelay(25);
		if (button==BUTTON_BCK) {
			dayTimerId--;
		}
		if (button==BUTTON_FWD) {
			dayTimerId++;
		}
	}
	Lcd_clear();
}

void EE_WriteWord(uint16_t Address, uint32_t Data){
	uint16_t tmp, tmp2;
	tmp2 = Data & 0xFFFF;
	tmp = Data >> 16;
	EE_WriteVariable(Address+1, tmp2);
	EE_WriteVariable(Address, tmp);
}

void programRunner(uint8_t programId){

	uint32_t tmp;
	switch (programId) {
	case 1:
		break;
	case 2:
	    setTimer(0);
		break;
	case 3:
		setTimer(1);
		break;
	case 4:
		setTimer(2);
		break;
	case 5:
		tmp = RTC_GetCounter();
		uint32_t unixtime = timeAdjust(tmp, 1);
		RTC_SetCounter(unixtime);
		Lcd_clear();
		break;
	case 6:
	    setCTimer(0);
		break;
	case 7:
		setCTimer(1);
		break;
	case 8:
		setCTimer(2);
		break;
	case 9:
		setPlug(0);
		break;
	case 10:
		setPlug(1);
		break;
	case 11:
		setPlug(2);
		break;
	case 13:
		phMonSettings();
		break;
	case 14:
		lightRangeSet();
		break;
	case 15:
		calibratePh();
		break;
	case 17:
		loggerSettings();
		break;

	}
}

void loggerSettings(void){
	uint32_t logSetting;
//	char value[8];
	vTaskDelay(10);
	Lcd_clear();
	EE_ReadVariable(SD_LOG_INTERVAL, &logSetting);
	vTaskDelay(100);
	Lcd_goto(0,0);
	Lcd_write_str("Log frequency");
	vTaskDelay(3000);
	logSetting=adjust8bit(logSetting);	// poluchit' novoe znachenie ot user'a
	EE_WriteVariable(SD_LOG_INTERVAL, logSetting);
	vTaskDelay(50);
	Lcd_clear();
	Lcd_goto(0,2);
	Lcd_write_str("Complete!");
	vTaskDelay(500);
	loadSettings();
	Lcd_clear();
}

void phMonSettings(void) {
//	uint16_t Address;
	uint32_t phSetting;
//	char value[8];
	vTaskDelay(10);
	Lcd_clear();
	EE_ReadVariable(PH_INTERVAL, &phSetting);
	vTaskDelay(100);
	Lcd_goto(0,0);
	Lcd_write_str("Probing interval");
	vTaskDelay(1000);
	phSetting=adjust8bit(phSetting);	// poluchit' novoe znachenie ot user'a
	EE_WriteVariable(PH_INTERVAL, phSetting);
	vTaskDelay(50);


	// analogichno dlja buffer size
	EE_ReadVariable(PH_BUFF_SIZE, &phSetting);
	Lcd_clear();
	Lcd_goto(0,2);
	Lcd_write_str("Buffer size");
	vTaskDelay(500);
	phSetting=adjust8bit(phSetting);	// poluchit' novoe znachenie ot user'a
	EE_WriteVariable(PH_BUFF_SIZE, phSetting);
	Lcd_clear();
	Lcd_goto(0,2);
	Lcd_write_str("Complete!");
	vTaskDelay(500);
	loadSettings();
	Lcd_clear();
}

uint8_t adjust8bit(uint8_t val){

	uint8_t button;
	if (val>99) {val=99;}
	while (button!=BUTTON_OK) {
		button=readButtons();
		vTaskDelay(25);
		if (button==BUTTON_BCK) {
			if (val<1) {
				val=99;
			}
			else {
				val--;
			}
		}
		if (button==BUTTON_FWD) {
			if (val>98) {
				val=0;
			}
			else {
				val++;
			}
		}
		Lcd_goto(1,0);
		Lcd_write_str("numero <");
		Lcd_write_digit(val);
		Lcd_write_str(">");
		vTaskDelay(25);
	}
	return val;
}

uint32_t CTimerAdjust(uint32_t time){
	uint8_t hours, minutes, seconds, hours2, minutes2, seconds2, button;
	char timestr[6];
	seconds = time % 60;
	time /= 60;
	minutes = time % 60;
	time /= 60;
	hours = time % 24;
	Lcd_clear();
	vTaskDelay(20);
	while (button!=BUTTON_FWD)
	{
		button=readButtons();
		if (button==BUTTON_BCK)
			{
				if (hours>98) {hours=0;}	// chtoby pechatat' pobolee znakov, nado zamenit' Lcd_write_digit()
				else {hours++;}
			}
		if (button==BUTTON_OK)
			{
				if (minutes>58) {minutes=0;}
				else {minutes++;}
			}
		if (button==BUTTON_CNL)
			{
				if (seconds>58) {seconds=0;}
				else {seconds++;}
			}

    	vTaskDelay(5);
		Lcd_goto(0,4);
    	Lcd_write_digit(hours);
    	Lcd_write_str(":");
    	Lcd_write_digit(minutes);
    	Lcd_write_str(":");
    	Lcd_write_digit(seconds);
    	vTaskDelay(5);
    	hours2=hours;		// daby izbezhat' konversii tipov pri umnozhenii na 3600 i podobnom
    	minutes2=minutes;
    	seconds2=seconds;
    	time=hours2*3600;
    	time+=minutes2*60;
    	time+=seconds2;
    	vTaskDelay(5);
    	Lcd_goto(1,3);
    	int32str(time, &timestr);
//    	Lcd_write_arr(&timestr, 6);
    	copy_arr(&timestr, LCDLine2, 10, 2);
    	vTaskDelay(10);
	}
	return(time);
}

void setCTimer(uint8_t timerId){
	uint16_t Address;
	uint32_t CTimerData;
//	char value[8];
	vTaskDelay(10);
	Lcd_clear();
	Address = EE_CTIMER_DURATION+timerId*EE_CTIMER_SIZE;
	CTimerData = EE_ReadWord(Address);
	if (CTimerData>356400) {
		CTimerData=356400;
	}
	Lcd_goto(0,2);
	Lcd_write_str("Set DURATION");
	vTaskDelay(3000);
	CTimerData=CTimerAdjust(CTimerData);	// poluchit' novoe znachenie ot user'a
	Address = EE_CTIMER_DURATION+timerId*EE_CTIMER_SIZE;	// adres postojanno "napominaetsja", potomu chto po-hodu ispolnenija koda on kuda-to "terjaetsja". bylo by neploho razobratsja kuda
	EE_WriteWord(Address, CTimerData);
	vTaskDelay(50);


	// analogichno dlja INTERVALa
	Address = EE_CTIMER_INTERVAL+timerId*EE_CTIMER_SIZE;
	CTimerData = EE_ReadWord(Address);
	Lcd_clear();
	Lcd_goto(0,2);
	Lcd_write_str("Set INTERVAL");
	vTaskDelay(500);
	CTimerData=CTimerAdjust(CTimerData);	// poluchit' novoe znachenie ot user'a
	Address = EE_CTIMER_INTERVAL+timerId*EE_CTIMER_SIZE;
	EE_WriteWord(Address, CTimerData);
	Lcd_clear();
	Lcd_goto(0,2);
	Lcd_write_str("Complete!");
	vTaskDelay(500);
	Lcd_clear();
}

void setTimer(uint8_t timerId){
//	timerId--;	// chtoby Timer 1 byl nulevym
	uint32_t Data, adjusteDate;
	uint16_t Address;
	int curval=0;
	Address = EE_TIMER1_ON+timerId*EE_TIMER_SIZE;	// set ON for plain timer
//	char value[6];
//	uint8_t button=0;
	Lcd_clear();
	Lcd_goto(0,2);
	Lcd_write_str("Set ON time");
	vTaskDelay(3000);
	Lcd_clear();
	vTaskDelay(50);
	Data = EE_ReadWord(Address);
	vTaskDelay(50);
	adjusteDate = timeAdjust(Data, 1);
	EE_WriteWord(Address, adjusteDate);
	Lcd_clear();
	Lcd_goto(0,2);
	Lcd_write_str("Set OFF time");
	vTaskDelay(50);
	vTaskSuspendAll();
	Address = EE_TIMER1_ON+timerId*EE_TIMER_SIZE+2;	// set OFF for plain timer
	Data = EE_ReadWord(Address);
	xTaskResumeAll();
	vTaskDelay(3000);
	Lcd_clear();
	adjusteDate = timeAdjust(Data, 1);
	EE_WriteWord(Address, adjusteDate);
	Lcd_clear();
	vTaskDelay(50);
	vTaskSuspendAll();
	Address = EE_TIMER1_ON+timerId*EE_TIMER_SIZE+4;	// set daily flag
	Data = EE_ReadWord(Address);
	xTaskResumeAll();
//	dowSelector();
	curval = Data & 1;
	vTaskDelay(50);
//	yesNoSelector("Every day?", curval);
	Lcd_clear();
}

int yesNoSelector(char str, int curval){
	Lcd_clear();
	Lcd_goto(0,0);
	Lcd_write_str(str);
	vTaskDelay(50);
	uint8_t button=0;
	vTaskDelay(50);
	while (button!=BUTTON_OK) {
		if (button==BUTTON_FWD || button==BUTTON_BCK) {
/*			Lcd_goto(1,5);
			curval |= 1;
			vTaskDelay(50);
			if (curval==0){
				Lcd_write_str("< NO >");
			}
			vTaskDelay(50);
			if (curval==1){
				Lcd_write_str("< SI >");
			}
			vTaskDelay(50);
			button=readButtons();
			vTaskDelay(50); */
		}
		vTaskDelay(50);

	}
//	vTaskDelay(50);
	return(curval);
}

uint32_t timeAdjust(uint32_t cnt, uint8_t includeDays)
{
	uint32_t unixtime2;
	uint8_t button=0;
	RTC_DateTime curtime, curtime2;
	char unixtimestr[11];
	curtime=unix2DateTime(cnt);

	while (button!=BUTTON_FWD)
	{
		button=readButtons();
		if (button==BUTTON_BCK)
			{
				if (curtime.hour>22) {curtime.hour=0;}
				else {curtime.hour++;}
			}
		if (button==BUTTON_OK)
			{
				if (curtime.min>58) {curtime.min=0;}
				else {curtime.min++;}
			}
		if (button==BUTTON_CNL)
			{
				if (curtime.sec>58) {curtime.sec=0;}
				else {curtime.sec++;}
			}
    	vTaskDelay(5);
		Lcd_goto(0,0);
    	Lcd_write_digit(curtime.hour);
    	Lcd_write_str(":");
    	Lcd_write_digit(curtime.min);
    	Lcd_write_str(":");
    	Lcd_write_digit(curtime.sec);

		unixtime2=DateTime2unix(curtime);
		curtime2=unix2DateTime(unixtime2);
    	int32str(unixtime2, &unixtimestr);
		Lcd_goto(0,10);
    	Lcd_write_digit(curtime2.hour);
    	Lcd_write_digit(curtime2.min);
    	Lcd_write_digit(curtime2.sec);
    	Lcd_goto(1,2);
    	vTaskDelay(5);
    	copy_arr(&unixtimestr, LCDLine2, 10, 2);
    	vTaskDelay(20);
	}
	button=0;
	if (includeDays==1) {
			while (button!=BUTTON_FWD)
				{
					button=readButtons();
					if (button==BUTTON_CNL)
						{
							if (curtime.year>50) {curtime.year=12;}
							else {curtime.year++;}
						}
					if (button==BUTTON_OK)
						{
							if (curtime.month>11) {curtime.month=1;}
							else {curtime.month++;}
						}
					if (button==BUTTON_BCK)
						{
							if (curtime.day>30) {curtime.day=1;}
							else {curtime.day++;}
						}

			    	vTaskDelay(5);
			    	// preobrazovanija tuda-sjuda dlja togo chtoby ubeditsja, chto funkcii rabotajut verno
					unixtime2=DateTime2unix(curtime);
					curtime2=unix2DateTime(unixtime2);
			    	int32str(unixtime2, &unixtimestr);
			    	//Lcd_clear();
			    	vTaskDelay(5);
					Lcd_goto(0,0);
			    	Lcd_write_digit(curtime.day);
			    	Lcd_write_str("-");
			    	Lcd_write_digit(curtime.month);
			    	Lcd_write_str("-");
			    	Lcd_write_digit(curtime.year);
			    	vTaskDelay(5);
					Lcd_goto(0,10);
			    	Lcd_write_digit(curtime2.day);
			    	Lcd_write_digit(curtime2.month);
			    	Lcd_write_digit(curtime2.year);
			    	vTaskDelay(5);
			    	copy_arr(&unixtimestr, LCDLine2, 10, 2);
					vTaskDelay(50);
			}
		}
	else {
		unixtime2 = 0;
		unixtime2 += curtime.hour*3600;
		unixtime2 += curtime.min*60;
		unixtime2 += curtime.sec;
	}
	return(unixtime2);
}

void Lcd_write_arr2(uc8 *STRING, uint8_t chars)
{
	char c;
	uint8_t i;
	for (i=0; i<chars; i++) {
		c=STRING[i];
//		vTaskDelay(5);
		Lcd_write_data(c);
	}
}

void Lcd_write_arr(uc8 *STRING, uint8_t chars)
{
	char c;
	uint8_t i;
	for (i=0; i<chars; i++) {
		c=STRING[i];
		Lcd_write_data(c);
	}
}


/* void Lcd_print(char *STRING)
{
	Init_pin_out();
	char c; //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â» Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â· Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¸
	while (c=*STRING++){
		GPIO_Write(port,((c>>4)<<lcd_shift)); // Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦
		e_1;rs_1;
		del=10; while (del--){}
		e_0;
		GPIO_Write(port,(0x00)<<lcd_shift);
		GPIO_Write(port,((c&0x0F)<<lcd_shift));// Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬â€�Ãƒï¿½Ã¢â‚¬Â¦
		del=10; while (del--){}
		e_1;rs_1;
		del=10; while (del--){}
		e_0;rs_0;rw_0;
		GPIO_Write(port,(0x00)<<lcd_shift);
	}
}
*/


RTC_DateTime unix2DateTime(uint32_t unixtime)
{
	RTC_DateTime datetime;
	uint32_t tmp;
	uint8_t leaps, month, day;
	uint16_t daysFromLeap, dayOfYearLeaped;
	tmp = unixtime-YEAR12SECS;	// vse raschety vedutsja ot 01.01.2012 00:00:00

	datetime.sec = unixtime % 60;
	unixtime /= 60;
	datetime.min = unixtime % 60;
	unixtime /= 60;
	datetime.hour = unixtime % 24;
	tmp /= 86400;
	daysFromLeap = tmp % 1461;	// 86400*1461=126230400 secs in leap cycle
	leaps=tmp/1461;
	daysFromLeap++;

	if (daysFromLeap<59)	// 1..60
	{
		datetime.year=leaps*4+12;
		dayOfYearLeaped=daysFromLeap+1;	// for shifting days because of 29.03

	}
	if (daysFromLeap>=59 && daysFromLeap<=366)		// 61..366
	{
		datetime.year=leaps*4+(daysFromLeap-1)/365+12;
		dayOfYearLeaped=daysFromLeap;
	}
	if (daysFromLeap>=366) {								// 367..1461
		datetime.year=leaps*4+(daysFromLeap-1)/365+12;
		dayOfYearLeaped=((daysFromLeap-366) % 365)+1;
	}

	if (dayOfYearLeaped>=1 && dayOfYearLeaped<=31)
	{
		month=1;	// january
		day=dayOfYearLeaped;
	}
	if (dayOfYearLeaped>=32 && dayOfYearLeaped<=59)
	{
		month=2;	// february
		day=dayOfYearLeaped-31;
	}
	if (dayOfYearLeaped>=60 && dayOfYearLeaped<=90)
	{
		month=3;	// march
		day=dayOfYearLeaped-59;
	}
	if (dayOfYearLeaped>=91 && dayOfYearLeaped<=120)
	{
		month=4;	// april
		day=dayOfYearLeaped-90;
	}
	if (dayOfYearLeaped>=121 && dayOfYearLeaped<=151)
	{
		month=5;	// may
		day=dayOfYearLeaped-120;
	}
	if (dayOfYearLeaped>=152 && dayOfYearLeaped<=181)
	{
		month=6;	// june
		day=dayOfYearLeaped-151;
	}
	if (dayOfYearLeaped>=182 && dayOfYearLeaped<=212)
	{
		month=7;	// july
		day=dayOfYearLeaped-181;
	}
	if (dayOfYearLeaped>=213 && dayOfYearLeaped<=243)
	{
		month=8;	// august
		day=dayOfYearLeaped-212;
	}
	if (dayOfYearLeaped>=244 && dayOfYearLeaped<=273)
	{
		month=9;	// september
		day=dayOfYearLeaped-243;
	}
	if (dayOfYearLeaped>=274 && dayOfYearLeaped<=304)
	{
		month=10;	// october
		day=dayOfYearLeaped-273;
	}
	if (dayOfYearLeaped>=305 && dayOfYearLeaped<=334)
	{
		month=11;	// november
		day=dayOfYearLeaped-304;
	}
	if (dayOfYearLeaped>=335 && dayOfYearLeaped<=365)
	{
		month=12;	// december
		day=dayOfYearLeaped-334;
	}
	datetime.day=day;
	datetime.month=month;
	if (daysFromLeap==59) {
		datetime.day=29;
		datetime.month=2;
	}
	return(datetime);
}

uint32_t DateTime2unix(RTC_DateTime datetime)
{
	    uint32_t tmp;
///	    uint8_t i;
	    uint16_t days, dayFromYear;

	    switch (datetime.month) {
	    case 0:
	    	days=0;
	    case 1:
	    	days=0;
	    	break;
	    case 2:
	    	days=31;
	    	break;
	    case 3:
	    	days=59;
	    	break;
	    case 4:
	    	days=90;
	    	break;
	    case 5:
	    	days=120;
	    	break;
	    case 6:
	    	days=151;
	    	break;
	    case 7:
	    	days=181;
	    	break;
	    case 8:
	    	days=212;
	    	break;
	    case 9:
	    	days=243;
	    	break;
	    case 10:
	    	days=273;
	    	break;
	    case 11:
	    	days=304;
	    	break;
	    case 12:
	    	days=334;
	    	break;
	    }

	    dayFromYear = days+datetime.day;

	    if (dayFromYear<60 && (datetime.year % 4)==0){
	    	dayFromYear--;
	    }
	    if (datetime.month==2 && datetime.day>=29 && (datetime.year % 4)==0) {
	        dayFromYear--;
	    }
	    if (dayFromYear<1){dayFromYear=1;}
	    tmp = ((datetime.year-12) * 365 * 86400);
	    tmp += (datetime.hour * 3600);
	    tmp += (datetime.min * 60);
	    tmp += (datetime.sec + YEAR12SECS);
	    tmp += ((dayFromYear-2)*86400);
	    tmp+=(((datetime.year-8)/4)*86400);
	    return tmp;
}

// function returns the programId selected in menu to run the program
int menuSelector(void)
{
	int curItem=0;	// default item to display entering the menu
	int programId = 0;
//	int buttonPressed=readButtons();
	int textId=fatArray[curItem][1];
	while (programId==0){
		textId=fatArray[curItem][1];
		Lcd_goto(0,0);
		Lcd_write_str(menuItemArray[textId]);
		int curButton=readButtons();
		if (curButton>0){
			vTaskDelay(100);
			Lcd_clear();
		}
		vTaskDelay(10);
		if (curButton==BUTTON_OK){
			if (fatArray[curItem][6]==1)		// run program
				{programId=fatArray[curItem][4];}
			else	{curItem=fatArray[curItem][4];}			// enter folder
			Lcd_clear();
		}
		else if (curButton==BUTTON_CNL){
			curItem=fatArray[curItem][5];
			Lcd_clear();
		}
		else if (curButton==BUTTON_BCK){
			curItem=fatArray[curItem][2];
			Lcd_clear();
		}
		else if (curButton==BUTTON_FWD){
			curItem=fatArray[curItem][3];
			Lcd_clear();
		}
	}
	vTaskDelay(1);
	return(programId);
}


//********************************************************************************************
//function  Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡ Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âº RTC                                                              //
//argument  none                                                                            //
//result    Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°                                              //
//********************************************************************************************
uint32_t RTC_GetCounter(void)
{
  return  (uint32_t)((RTC->CNTH << 16) | RTC->CNTL);
}

//********************************************************************************************
//function  Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â² Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âº RTC                                         //
//argument  Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°                                                         //
//result    none                                                                            //
//********************************************************************************************
void RTC_SetCounter(uint32_t value)
{
  RTC->CRL |= RTC_CRL_CNF;    //Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â»Ãƒâ€˜Ã…Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
  RTC->CNTH = value>>16;      //Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°
  RTC->CNTL = value;          //
  RTC->CRL &= ~RTC_CRL_CNF;   //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â· Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â° Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
}

//********************************************************************************************
//function Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½ RTC                                                                //
//argument none                                                                             //
//result   1 - Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°; 0 - Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¹ Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹                  //
//********************************************************************************************
unsigned char  RtcInit(void)
{
 //Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã‹â€ Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¹ Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â·Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™Ãƒâ€˜Ã…Â½
  RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
  //Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã‹â€ Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¿ Ãƒï¿½Ã‚Âº Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â·Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦
  PWR->CR |= PWR_CR_DBP;
  //Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¹ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â»Ãƒâ€˜Ã…Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹ - Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â¦
  if ((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
  {
    //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â·Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦
    RCC->BDCR |=  RCC_BDCR_BDRST;
    RCC->BDCR &= ~RCC_BDCR_BDRST;

    //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦ Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã…â€™Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â² Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â½utrennij Q 40kHz Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ
//    RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSI;

    //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦ Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã…â€™Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â² Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã‹â€ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Â  32768 Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ
    RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;

    RTC->CRL  |=  RTC_CRL_CNF;
    RTC->PRLL  = 0x7FFF;         //Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â° 32768
    RTC->CRL  &=  ~RTC_CRL_CNF;

    RCC->BDCR |= RCC_BDCR_LSEON;
    while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON){}

    RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
    while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF){}
    RTC_SetCounter(YEAR12SECS+(212+20)*86400+10*3600+9*60);
    return 1;
  }
  return 0;
}


 uint32_t TimeToRtc(RTC_Time *time )
{
  uint32_t result;
  result  = (uint32_t)time->hour * 3600; //Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¹
  result += (uint32_t)time->min * 60;    //Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹
  result +=           time->sec;         //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã¢â‚¬Â¹
  return result;
}

 void RtcToTime( uint32_t cnt, RTC_Time *time )
 {
   time->sec = cnt % 60;               //Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â´Ãƒâ€˜Ã¢â‚¬Â¹
   cnt /= 60;                          //Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Å¡
   time->min = cnt % 60;               //Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹
   cnt /= 60;                          //Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¹
   time->hour = cnt % 24;              //Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Â¹
 }

void phMonitor(void *pvParameters){
 	while(1){
 		int i=0;
 	    for(i=0; i < 9; i++) {
 	            phBuffer[i] = phBuffer[i+1];
 		}
 		phBuffer[9] = JDR_PH;
 		vTaskDelay(10);
 	}
}

void copy_arr(uint8_t *source, uint8_t *destination, uint8_t amount, uint8_t pos){
	int i=0;
	for (i=0; i<amount;i++) {
		destination[i+pos] = source[i];
	}
}

void displayClock(void *pvParameters)
{
		RTC_DateTime	DateTime;
		uint32_t i, tmp;
		uint8_t button;
		char str[6];
		Lcd_clear();
    	while (1)
	    {
    		tmp = RTC_GetCounter();
    		DateTime=unix2DateTime(tmp);
	    	LCDLine1[0]= (DateTime.day / 10) + 48;
	    	LCDLine1[1]= (DateTime.day % 10) + 48;
	    	LCDLine1[2]= 45;
	    	LCDLine1[3]= (DateTime.month / 10) + 48;
	    	LCDLine1[4]= (DateTime.month % 10) + 48;
	    	LCDLine1[5]= 45;
	    	LCDLine1[6]= (DateTime.year / 10) + 48;
	    	LCDLine1[7]= (DateTime.year % 10) + 48;
	    	LCDLine2[6]= 32;
	    	LCDLine2[7]= 32;


	    	Lcd_goto(1,0);
	    	Lcd_write_digit(DateTime.hour);
	    	Lcd_write_digit(DateTime.min);
	    	Lcd_write_digit(DateTime.sec);

	    	vTaskDelay(5);

	    	Lcd_goto(1,8);
	    	Lcd_write_str("pH:");
	    	vTaskDelay(5);
	    	getPh();
///			Lcd_write_arr(&curphstr, 4);
			copy_arr(&curphstr, LCDLine2, 4, 11);
	    	vTaskDelay(5);

//	    	getPh();
	    	vTaskDelay(9);		// was 590

	    	// vyvod flagov tajmerov
	    	uint16_t flg;
	    	Lcd_goto(0,10);
	    	for (i=0; i<3; i++) {
	    		flg=plugStateFlags&(1<<i);
	    		flg>>=i;
	    		Lcd_write_digit(flg);
	    	}

	    	vTaskDelay(11);
	    	adc2str(tmp, str);

	    	vTaskDelay(3);
//	    	Lcd_write_str("/");
	    	Lcd_write_str(str);
	    	button=readButtons();
//	    	adc2str(button, str);
	    	vTaskDelay(3);
	    	if (button==BUTTON_OK)
	    	{
	    		vTaskDelay(100);
	    		Lcd_clear();
	    		vTaskDelay(500);
	    		uint8_t progId=menuSelector();
	    		programRunner(progId);
	    	}

	    }
    	while (1) {


    	}
}

uint8_t readButtons(void){
	uint16_t curval = 0;
	uint8_t i;
	curval = JDR_BUTTONS;
	for (i=0;i<4;i++) {
		if (curval>button_ranges[i*2] && curval<button_ranges[i*2+1]) {
			return i+1;
		}
	}
	return 0;
}

/* uint8_t readButtons(void)	// funkcija zatochena pod 4 analogovyh knopki
{
	uint32_t buffersum, tmp, buffer[10];	// buffersum - dlja vychislenija srednego za 10 poslednih schityvanij, dlja uverennogo opredelenija nomera knopki.
	uint8_t button, i;
	i=10;
	while (i>0) {
		i--;
//		tmp=ADC1->DR;	//deprecated 09.09.2012
		tmp=JDR_BUTTONS;
//		if ((tmp>1400 & tmp<1500)||(tmp>2200 & tmp<2300)||(tmp>1900 & tmp<2000)||(tmp>2500 & tmp<2600)){
		if ((tmp>2350 & tmp<2600)||(tmp>2000 & tmp<2300)||(tmp>1700 & tmp<1950)||(tmp>1200 & tmp<1500)){
			buffer[i]=tmp;
			buffersum=buffersum+tmp;	// summiruem 10 znachenij s ADC
		}
	}
	tmp=buffersum/10;				// vychisljaem srednee i..
	// opredeljaem nomer knopki
	if (tmp>2350 & tmp<2600) {
		button=BUTTON_FWD;
	}
	else if (tmp>2000 & tmp<2300){
		button=BUTTON_CNL;
	}
	else if (tmp>1700 & tmp<1950){
		button=BUTTON_OK;
	}
	else if (tmp>1200 & tmp<1500){
		button=BUTTON_BCK;
	}
}
*/



void AdcInit(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;    // Ãƒï¿½Ã‚Â Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã‹â€ Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â° PORTA
	  //Ãƒï¿½Ã…Â¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ PORTA.3 - Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´
	  GPIOA->CRL   &= ~GPIO_CRL_MODE1;       //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ MODE
	  GPIOA->CRL   &= ~GPIO_CRL_CNF1;        //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ CNF
	  //Ãƒï¿½Ã…Â¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ PORTA.4 - Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´
	  GPIOA->CRL   &= ~GPIO_CRL_MODE2;       //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ MODE
	  GPIOA->CRL   &= ~GPIO_CRL_CNF2;        //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ CNF
	  //Ãƒï¿½Ã…Â¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ PORTA.5 - Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´
	  GPIOA->CRL   &= ~GPIO_CRL_MODE3;       //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ MODE
	  GPIOA->CRL   &= ~GPIO_CRL_CNF3;        //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ CNF
	  //Ãƒï¿½Ã…Â¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ PORTA.6 - Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´
	  GPIOA->CRL   &= ~GPIO_CRL_MODE4;       //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ MODE
	  GPIOA->CRL   &= ~GPIO_CRL_CNF4;        //Ãƒï¿½Ã…Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â±Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â‚¬Â¹ CNF

	  RCC->APB2ENR |=  RCC_APB2ENR_ADC1EN;   //Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã¯Â¿Â½Ãƒï¿½Ã‚Â¦Ãƒï¿½Ã…Â¸
	  RCC->CFGR    &= ~RCC_CFGR_ADCPRE;      //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒâ€˜Ã…â€™
	  ADC1->CR1     =  0;                    //Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â° Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°
	  ADC1->CR2    |=  ADC_CR2_CAL;          //Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Âº Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¸
	  while (!(ADC1->CR2 & ADC_CR2_CAL)){};  //Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¸
	  ADC1->CR2     =  ADC_CR2_JEXTSEL;      //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â° Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â´  JSWSTART
	  ADC1->CR2    |=  ADC_CR2_JEXTTRIG;     //Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â€šÂ¬. Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã‹â€ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Âº Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬Â¹
	  ADC1->CR2    |=  ADC_CR2_CONT;         //Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
	  ADC1->CR1    |=  ADC_CR1_SCAN;         //Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½ (Ãƒâ€˜Ã¢â‚¬Å¡.Ãƒï¿½Ã‚Âµ. Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã…â€™Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²)
	  ADC1->CR1    |=  ADC_CR1_JAUTO;	 //Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â‚¬Å¡. Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Âº Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â‚¬Â¹
	  ADC1->JSQR    =  (uint32_t)(4-1)<<20;  //Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â² Ãƒï¿½Ã‚Â² Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Âµ
	  ADC1->JSQR   |=  (uint32_t)1<<(5*0);   //Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â° Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
	  ADC1->JSQR   |=  (uint32_t)2<<(5*1);   //Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â° Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
	  ADC1->JSQR   |=  (uint32_t)3<<(5*2);   //Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â° Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã¯Â¿Â½ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
	  ADC1->JSQR   |=  (uint32_t)4<<(5*3);   //Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â° Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â»Ãƒâ€˜Ã¯Â¿Â½ Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
	  ADC1->CR2    |=  ADC_CR2_ADON;         //Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â»Ãƒâ€˜Ã…Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã¯Â¿Â½Ãƒï¿½Ã‚Â¦Ãƒï¿½Ã…Â¸
	  ADC1->CR2    |=  ADC_CR2_JSWSTART;     //Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã…â€™ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¯Â¿Â½ Ãƒï¿½Ã‚Â¿Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â±Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½
}

void Lcd_write_digit2(uint8_t numb){
	if (numb<10) {
		Lcd_write_data(48);
		Lcd_write_data(48+numb);
	}
	else {
		Lcd_write_data((numb/10)+48);
		Lcd_write_data((numb-(numb/10)*10)+48);
	}
}

void Lcd_write_digit(uint8_t numb){
	if (lcd_pointery==0) {
		LCDLine1[lcd_pointerx] = ((numb%100)/10)+48;
		lcd_pointerx++;
		LCDLine1[lcd_pointerx] = (numb%10)+48;
		lcd_pointerx++;
	}
	else {
		LCDLine2[lcd_pointerx] = ((numb%100)/10)+48;
		lcd_pointerx++;
		LCDLine2[lcd_pointerx] = (numb%10)+48;
		lcd_pointerx++;
	}
}





void prvSetupHardware()
{
//	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;     //Ãƒï¿½Ã¢â‚¬â„¢Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â»Ãƒâ€˜Ã…Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â° GPIOB.
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;     //Ãƒï¿½Ã¢â‚¬â„¢Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â»Ãƒâ€˜Ã…Â½Ãƒâ€˜Ã¢â‚¬Â¡Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â° GPIOC.
	        GPIOC->CRH      &= ~GPIO_CRH_CNF8;              // Ãƒï¿½Ã¯Â¿Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™ 8 (Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¹ LED) Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â° Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´ Push-Pull.
	        GPIOC->CRH      &= ~GPIO_CRH_CNF9;              // Ãƒï¿½Ã¯Â¿Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™ 9 (Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒâ€˜Ã¢â‚¬ËœÃƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹ LED) Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â° Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒâ€˜Ã¢â‚¬Â¦Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â´ Push-Pull.
	        GPIOC->CRL      &= ~GPIO_CRL_CNF0;
	        GPIOC->CRL      &= ~GPIO_CRL_CNF1;
	        GPIOC->CRL      &= ~GPIO_CRL_CNF2;
	        GPIOC->CRL      &= ~GPIO_CRL_CNF3;

	        GPIOC->CRH   |= GPIO_CRH_MODE8_0;       // Ãƒï¿½Ã¯Â¿Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™ 8 (Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¹ LED) Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â° 10MHz.
	        GPIOC->CRH   |= GPIO_CRH_MODE9_0;       // Ãƒï¿½Ã¯Â¿Â½Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒâ€˜Ã†â€™ 9 (Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒâ€˜Ã¢â‚¬ËœÃƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹
	        GPIOC->CRL   |= GPIO_CRL_MODE0_0;
	        GPIOC->CRL   |= GPIO_CRL_MODE1_0;
	        GPIOC->CRL   |= GPIO_CRL_MODE2_0;
	        GPIOC->CRL   |= GPIO_CRL_MODE3_0;
}

void prvLedBlink( void *pvParameters )
{
//	uint32_t i;

    while(1) {
        GPIOC->BRR = GPIO_BRR_BR8;              // Ãƒï¿½Ã…Â¸Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¹
        vTaskDelay(1000);
        GPIOC->BSRR = GPIO_BSRR_BS8;    // Ãƒï¿½Ã¢â‚¬â€�Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â¹
        vTaskDelay(1500);
//        Init_lcd();
//        Init_lcd();
    }
}

void vTaskLCDdraw(void *pvParameters) {	// draws lcd
//	uint32_t tmp=0;
//	int str;
	for (;;) {
		vTaskSuspendAll();
		Lcd_write_cmd(0x80);	// lcd_goto(0,0)
//		Lcd_goto(0,0);
		Lcd_write_arr(&LCDLine1, 16);
//		xTaskResumeAll();
//		vTaskDelay(15);
//		vTaskSuspendAll();
		Lcd_write_cmd(0x80+0x40);	// lcd_goto(1,0)
		Lcd_write_arr(&LCDLine2, 16);
		xTaskResumeAll();
		vTaskDelay(17);
	}
}


void prvLedBlink2( void *pvParameters )
{
//	uint32_t i;

    while(1) {
        GPIOC->BSRR = GPIO_BSRR_BS9;    // Ãƒï¿½Ã¢â‚¬â€�Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¶Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒâ€˜Ã¢â‚¬ËœÃƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹
        vTaskDelay(400);
        GPIOC->BRR = GPIO_BRR_BR9;              // Ãƒï¿½Ã…Â¸Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â³Ãƒï¿½Ã‚Â°Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸ Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒâ€˜Ã¢â‚¬ËœÃƒï¿½Ã‚Â½Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹
        vTaskDelay(400);
    }
}


void int32str(uint32_t d, char *out)
{
    out[10] = '\0';
    out[9] = '0' + ( d       )    % 10;
    out[8] = '0' + ( d /= 10 )    % 10;
    out[7] = '0' + ( d /= 10 )    % 10;
    out[6] = '0' + ( d /= 10 )    % 10;
    out[5] = '0' + ( d /= 10 )    % 10;
    out[4] = '0' + ( d /= 10 )    % 10;
    out[3] = '0' + ( d /= 10 )    % 10;
    out[2] = '0' + ( d /= 10 )    % 10;
    out[1] = '0' + ( d /= 10 )    % 10;
    out[0] = '0' + ( d /  10 )    % 10;
//    return out;
}

void int10str(uint32_t d, char *out)
{
    out[4] = '\0';
    out[3] = '0' + ( d       )    % 10;
    out[2] = '0' + ( d /= 10 )    % 10;
    out[1] = '0' + ( d /= 10 )    % 10;
    out[0] = '0' + ( d /  10 )    % 10;
//    return out;
}

uint32_t EE_ReadWord(uint16_t Address){
	uint16_t tmp, tmp2;
	uint32_t Data = 0;
	EE_ReadVariable(Address, &tmp);
	EE_ReadVariable(Address+1, &tmp2);
	Data = ((uint32_t)tmp << 16) + (uint32_t)tmp2;
	return Data;
}

void flush_lcd_buffer(void){
	uint8_t i=0;
	for (i=0;i<16;i++){
		LCDLine1[i]=32;
		LCDLine2[i]=32;
	}
}

int main(void)
{
	SystemInit();
	/* Unlock the Flash Program Erase controller */
	FLASH_Unlock();
	/* EEPROM Init */
	EE_Init();
	uint32_t tmp;
	char value[10];
	tmp = EE_ReadWord(0x8000);
	int32str(tmp, &value);
	AdcInit();

	uint32_t i;
	for (i=0; i<400000; i++) {}
	Init_lcd();

	buttonCalibration();
	Lcd_clear();
	Lcd_goto(1,0);
	Lcd_write_str(value);
	for (i=0; i<400000; i++) {}

//	DSTATUS resp=0;
//	  ......                        //Ãƒâ€˜Ã¢â‚¬Â¡Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾-Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼
//	  disk_initialize(0);           //Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã†â€™ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¼Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸
//	  f_mount(0, &fs);              //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â° Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¾ Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ fs
//	  resp = create_file("0:proba.txt");  //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚ÂµÃƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¹ Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¹Ãƒï¿½Ã‚Â»
//	  create_file("0:proba2.txt"); //Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ Ãƒâ€˜Ã¢â‚¬Å¾Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¹Ãƒï¿½Ã‚Â»
//	  f_mount(0, NULL);             //Ãƒï¿½Ã‚Â¾Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¼Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â½Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â° Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¾ Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ fs

//	  ......                        //Ãƒâ€˜Ã¢â‚¬Â¡Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾-Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¾ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼

//		Lcd_clear();
//		Lcd_goto(1,0);
//		Lcd_write_digit(resp);



	prvSetupHardware();

//	plugStateSet(3, 1);
//	plugStateSet(2, 1);		// does not work at all. led rojo
	for (i=0; i<200000; i++) {}
	plugStateSet(1, 1);
	for (i=0; i<200000; i++) {}
	plugStateSet(0, 1);
	for (i=0; i<400000; i++) {}

//    RTC_SetCounter(YEAR12SECS+(212+20)*86400+10*3600+9*60);
	RtcInit();

	DSTATUS resp=0;
	no_sd = disk_initialize(0);           //Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â‚¬Â Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Â·Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â°Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã†â€™ Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â¼Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒï¿½Ã‚Â¸
	loadSettings();
	if (no_sd==0){
		no_sd = f_mount(0, &fs);              //Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â¿Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â»Ãƒï¿½Ã‚Â½Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂµÃƒï¿½Ã‚Â¼ Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â²Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â·Ãƒâ€˜Ã¢â‚¬Â¹Ãƒï¿½Ã‚Â²Ãƒï¿½Ã‚Â°Ãƒï¿½Ã‚Â½Ãƒï¿½Ã‚Â¸Ãƒï¿½Ã‚Âµ Ãƒï¿½Ã‚Â´Ãƒï¿½Ã‚Â¸Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚ÂºÃƒï¿½Ã‚Â° Ãƒâ€˜Ã¯Â¿Â½Ãƒï¿½Ã‚Â¾ Ãƒâ€˜Ã¯Â¿Â½Ãƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã¢â€šÂ¬Ãƒâ€˜Ã†â€™Ãƒï¿½Ã‚ÂºÃƒâ€˜Ã¢â‚¬Å¡Ãƒâ€˜Ã†â€™Ãƒâ€˜Ã¢â€šÂ¬Ãƒï¿½Ã‚Â¾Ãƒï¿½Ã‚Â¹ fs
		no_sd = string2log("System started\n", 15);
	}


	Lcd_clear();
	Lcd_goto(1,0);
	Lcd_write_digit(no_sd);
	loadSettings();
	flush_lcd_buffer();
    		for (i=0; i<4000000; i++) {}
    xTaskCreate(prvLedBlink,(signed char*)"LED",configMINIMAL_STACK_SIZE,
            NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(prvLedBlink2,(signed char*)"LED2",configMINIMAL_STACK_SIZE,
            NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(displayClock,(signed char*)"CLK",100,
            NULL, tskIDLE_PRIORITY + 2, NULL);
    xTaskCreate(timerStateTrigger,(signed char*)"TIMERS",configMINIMAL_STACK_SIZE,
            NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(plugStateTrigger,(signed char*)"PLUGS",configMINIMAL_STACK_SIZE,
            NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(phMonitor,(signed char*)"PHMON",configMINIMAL_STACK_SIZE,
            NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(vTaskLCDdraw,(signed char*)"LCDDRW",configMINIMAL_STACK_SIZE,
            NULL, tskIDLE_PRIORITY + 1, NULL);
if (resp==0){
	xTaskCreate(sdLog,(signed char*)"SDLOG",256,NULL, tskIDLE_PRIORITY + 1, NULL);
}


/* Start the scheduler. */

    vTaskStartScheduler();

    while(1);
}


void loadSettings(void){	//
	uint16_t i, Address, Data;
	char tmpstr[11], putstring[50];
	for (i=0; i<PLUG_AMOUNT; i++) {
		Address=EE_PLUG_SETTINGS+i;
		EE_ReadVariable(Address, &Data);
		plugSettings[i]=Data;
		if (no_sd>1) {
			string2log("plug no.", 8);
			int32str(i,&tmpstr);
			string2log(tmpstr, 11);
			string2log(" has timer no.", 14);
			int32str(plugSettings[i],&tmpstr);
			tmpstr[10] = 0x0A;
			string2log(tmpstr, 11);
		}
	}
	Address=LIGHT_RANGE_ADDR;
	EE_ReadVariable(Address, &lightRange);
	EE_ReadVariable(PH4_ADDR, &ph4);

//	Address=PH7_ADDR;
	EE_ReadVariable(PH7_ADDR, &ph_seven);
	cdel = (ph_seven - ph4)/3;
	ph0 = ph4 - cdel*4;

	if (no_sd>0) {
		// vnesti v log znachenie kalibrovshika ph4
		int32str(ph4,&tmpstr);
		for (i=0;i<10;i++){
			putstring[i]=tmpstr[i];
		}
		putstring[10] = 0x0A;
		string2log("ph4 cal @ ", 10);
		string2log(putstring, 11);

		// vnesti v log znachenie kalibrovshika ph7
		int32str(ph_seven,&tmpstr);
		for (i=0;i<10;i++){
			putstring[i]=tmpstr[i];
		}
		putstring[10] = 0x0A;
		string2log("ph7 cal @ ", 10);
		string2log(putstring, 11);

		// vnesti v log raschitayj uroven' ph0
		int32str(ph0,&tmpstr);
		for (i=0;i<10;i++){
			putstring[i]=tmpstr[i];
		}
		putstring[14] = 10;
		string2log("ph0 counted @ ", 14);
		string2log(putstring, 11);

		// vnesti v log raschitanuju cenu delenija
		int32str(cdel,&tmpstr);
		for (i=0;i<10;i++){
			putstring[i]=tmpstr[i];
		}
		putstring[14] = 10;
		string2log("cena delenija ", 14);
		string2log(putstring, 11);
	}

	EE_ReadVariable(SD_LOG_INTERVAL, &logInterval);
}

void set4highBits(uint8_t dta){		// setting higher 4 bits of word on corresponding GPIO pins
	if (dta&16) lcd_port->BSRRL |= (pin_d4);
	else lcd_port->BSRRH |= (pin_d4);
	if (dta&32) lcd_port->BSRRL |= (pin_d5);
	else lcd_port->BSRRH |= (pin_d5);
	if (dta&64) lcd_port->BSRRL |= (pin_d6);
	else lcd_port->BSRRH |= (pin_d6);
	if (dta&128) lcd_port->BSRRL |= (pin_d7);
	else lcd_port->BSRRH |= (pin_d7);
}


void Lcd_write_str(char *STRING)
{
	char c;
	while (c=*STRING++){
		if (lcd_pointery==0) {
			LCDLine1[lcd_pointerx] = c;
			lcd_pointerx++;
		}
		else {
			LCDLine2[lcd_pointerx] = c;
			lcd_pointerx++;
		}
	}
}

void Lcd_goto(uc8 x,uc8 y)
{
	int str;
	str = y + 0x80;
	if(x == 1)
	{
	str+= 0x40;
	}
	Lcd_write_cmd(str);
	lcd_pointerx = y;
	lcd_pointery = x;
}

void Init_pin_out()
{
	RCC_APB2PeriphClockCmd(init_port, ENABLE);
	GPIO_InitTypeDef init_pin;
	init_pin.GPIO_Pin  = pin_e | pin_rs | pin_rw | pin_d7 | pin_d6 | pin_d5 | pin_d4;
	init_pin.GPIO_Mode = GPIO_Mode_Out_PP;
	init_pin.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init (port, &init_pin);
}

void Init_pin_in()
{
	RCC_APB2PeriphClockCmd(init_port, ENABLE);
	GPIO_InitTypeDef init_pin;
	init_pin.GPIO_Pin  =  pin_d7 | pin_d6 | pin_d5 | pin_d4 ;
	init_pin.GPIO_Mode = GPIO_Mode_IPD;
	init_pin.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init (port, &init_pin);
}

void Lcd_write_cmd(uc8 cmd )
{
		Delay_us(6);	// stable 240
		rs_0;rw_0;e_1;
		Delay_us(1);
		set4highBits(cmd);
		e_0;
		Delay_us(1);
		e_1;
		Delay_us(1);
		set4lowBits(cmd);
		e_0;
		Delay_us(6);
}

void Lcd_write_data(uint8_t data)
{
	Delay_us(6);
	e_1;rs_1;rw_0;
	Delay_us(1);
	set4highBits(data);
	Delay_us(1);
	e_0;
	Delay_us(1);
	e_1;
	Delay_us(1);
	set4lowBits(data);
	Delay_us(1);
	e_0;
	Delay_us(1);
	e_0;rs_0;rw_0;
	Delay_us(6);
}

void set4lowBits(uint8_t dta){
	if (dta&1) lcd_port->BSRRL |= (pin_d4);
	else lcd_port->BSRRH |= (pin_d4);
	if (dta&2) lcd_port->BSRRL |= (pin_d5);
	else lcd_port->BSRRH |= (pin_d5);
	if (dta&4) lcd_port->BSRRL |= (pin_d6);
	else lcd_port->BSRRH |= (pin_d6);
	if (dta&8) lcd_port->BSRRL |= (pin_d7);
	else lcd_port->BSRRH |= (pin_d7);

}

void Init_lcd()
{
	Init_pin_out();
//	  Delay_us(10000);
	  e_1;rs_0;rw_0;
	      Delay_us(100);	// assume 10ms
	      set4lowBits(0b0010);	// set 4 bit bus
	      e_0;
	      Delay_us(10);	// assume 10ms

	      Lcd_write_cmd(0b00101000);	// again, 4bit bus and the rest 4bits of whole command will get the destination now
	      Delay_us(10);
//	  	  del=72000; while (del--){}
	  	  Lcd_write_cmd(Display_clear);
//	      del=72000; while (del--){}

		  Lcd_write_cmd(0b00000110);	// function set
//		  del=72000; while (del--){}

		  Lcd_write_cmd(0b00001100);	// display on cursor off
//		  del=72000; while (del--){}


		  Lcd_write_cmd(Display_clear);	// function set
//		  del=72000; while (del--){}

//		  Lcd_write_str("A");



//		  Lcd_write_str("12345678");


	  	Delay_us(10);
}

void Lcd_clear()
{
	Lcd_write_cmd(Display_clear);
	flush_lcd_buffer();
}

void Return_home()
{
	Lcd_write_cmd(0b0000001);
}


